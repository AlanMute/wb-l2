package pattern

import "fmt"

/*
	Фабричный метод — это порождающий паттерн проектирования,
	который определяет общий интерфейс для создания объектов в суперклассе,
	позволяя подклассам изменять тип создаваемых объектов.

	Пусть у нас есть система для доставки товаров для грузовиков.
	Со временем она стала популярна и нужно добавить в эту систему морские суда.
	Но проблема в том что наш код работает только с грузовиками. Че делать?

	Можно воспользоваться паттерном фабричный метод и создавать объекты траспорта через него.
	Сама система должна работать именно с траспортом(Интерфейсом) В котором должна быть реализация метода доставить.
	Как она будет реализовано фабрике все равно.
	Таким образом можно добавлять и другие траспорты для поддержки.

	Плюсы:
	- Избавляет класс от привязки к конкретным классам продуктов.
	- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
	- Упрощает добавление новых продуктов в программу.
	- Реализует принцип открытости/закрытости.

	Минусы:
	- Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.

	В качестве примера представим что есть фабрика по производству оружий(MP-5, Ak-74)
*/

type IGun interface { // Интерфейс продукта
	GetName() string
	GetPower() int
}

type Gun struct { // конкретный продукт
	name  string
	power int
}

func (g *Gun) GetName() string {
	return g.name
}

func (g *Gun) GetPower() int {
	return g.power
}

type Mp5 struct {
	Gun
}

func newMp5() IGun {
	return &Gun{
		name:  "MP-5",
		power: 10,
	}
}

type Ak74 struct {
	Gun
}

func newAk74() IGun {
	return &Gun{
		name:  "Ak-74",
		power: 10,
	}
}

// Теперь реализуем фабрику
func makeGun(name string) (IGun, error) {
	if name == "Ak-74" {
		return newAk74(), nil
	}
	if name == "MP-5" {
		return newMp5(), nil
	}
	return nil, fmt.Errorf("Нет такого, ты шо")
}

// func main() {
// 	ak74, _ := makeGun("Ak-74")
// 	mp, _ := makeGun("MP-5")

// 	fmt.Println(ak74.GetName())
// 	fmt.Println(mp.GetName())
// }
